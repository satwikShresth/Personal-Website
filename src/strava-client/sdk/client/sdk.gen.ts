// This file is auto-generated by @hey-api/openapi-ts

import { type Client, formDataBodySerializer, type Options as Options2, type TDataShape } from './client';
import { client } from './client.gen';
import type { CreateActivityData, CreateActivityErrors, CreateActivityResponses, CreateUploadData, CreateUploadErrors, CreateUploadResponses, ExploreSegmentsData, ExploreSegmentsErrors, ExploreSegmentsResponses, GetActivityByIdData, GetActivityByIdErrors, GetActivityByIdResponses, GetActivityStreamsData, GetActivityStreamsErrors, GetActivityStreamsResponses, GetClubActivitiesByIdData, GetClubActivitiesByIdErrors, GetClubActivitiesByIdResponses, GetClubAdminsByIdData, GetClubAdminsByIdErrors, GetClubAdminsByIdResponses, GetClubByIdData, GetClubByIdErrors, GetClubByIdResponses, GetClubMembersByIdData, GetClubMembersByIdErrors, GetClubMembersByIdResponses, GetCommentsByActivityIdData, GetCommentsByActivityIdErrors, GetCommentsByActivityIdResponses, GetEffortsBySegmentIdData, GetEffortsBySegmentIdErrors, GetEffortsBySegmentIdResponses, GetGearByIdData, GetGearByIdErrors, GetGearByIdResponses, GetKudoersByActivityIdData, GetKudoersByActivityIdErrors, GetKudoersByActivityIdResponses, GetLapsByActivityIdData, GetLapsByActivityIdErrors, GetLapsByActivityIdResponses, GetLoggedInAthleteActivitiesData, GetLoggedInAthleteActivitiesErrors, GetLoggedInAthleteActivitiesResponses, GetLoggedInAthleteClubsData, GetLoggedInAthleteClubsErrors, GetLoggedInAthleteClubsResponses, GetLoggedInAthleteData, GetLoggedInAthleteErrors, GetLoggedInAthleteResponses, GetLoggedInAthleteStarredSegmentsData, GetLoggedInAthleteStarredSegmentsErrors, GetLoggedInAthleteStarredSegmentsResponses, GetLoggedInAthleteZonesData, GetLoggedInAthleteZonesErrors, GetLoggedInAthleteZonesResponses, GetRouteAsGpxData, GetRouteAsGpxErrors, GetRouteAsGpxResponses, GetRouteAsTcxData, GetRouteAsTcxErrors, GetRouteAsTcxResponses, GetRouteByIdData, GetRouteByIdErrors, GetRouteByIdResponses, GetRoutesByAthleteIdData, GetRoutesByAthleteIdErrors, GetRoutesByAthleteIdResponses, GetRouteStreamsData, GetRouteStreamsErrors, GetRouteStreamsResponses, GetSegmentByIdData, GetSegmentByIdErrors, GetSegmentByIdResponses, GetSegmentEffortByIdData, GetSegmentEffortByIdErrors, GetSegmentEffortByIdResponses, GetSegmentEffortStreamsData, GetSegmentEffortStreamsErrors, GetSegmentEffortStreamsResponses, GetSegmentStreamsData, GetSegmentStreamsErrors, GetSegmentStreamsResponses, GetStatsData, GetStatsErrors, GetStatsResponses, GetUploadByIdData, GetUploadByIdErrors, GetUploadByIdResponses, GetZonesByActivityIdData, GetZonesByActivityIdErrors, GetZonesByActivityIdResponses, StarSegmentData, StarSegmentErrors, StarSegmentResponses, UpdateActivityByIdData, UpdateActivityByIdErrors, UpdateActivityByIdResponses, UpdateLoggedInAthleteData, UpdateLoggedInAthleteErrors, UpdateLoggedInAthleteResponses } from './types.gen';
import { zCreateActivityData, zCreateActivityResponse, zCreateUploadData, zCreateUploadResponse, zExploreSegmentsData, zExploreSegmentsResponse, zGetActivityByIdData, zGetActivityByIdResponse, zGetActivityStreamsData, zGetActivityStreamsResponse, zGetClubActivitiesByIdData, zGetClubActivitiesByIdResponse, zGetClubAdminsByIdData, zGetClubAdminsByIdResponse, zGetClubByIdData, zGetClubByIdResponse, zGetClubMembersByIdData, zGetClubMembersByIdResponse, zGetCommentsByActivityIdData, zGetCommentsByActivityIdResponse, zGetEffortsBySegmentIdData, zGetEffortsBySegmentIdResponse, zGetGearByIdData, zGetGearByIdResponse, zGetKudoersByActivityIdData, zGetKudoersByActivityIdResponse, zGetLapsByActivityIdData, zGetLapsByActivityIdResponse, zGetLoggedInAthleteActivitiesData, zGetLoggedInAthleteActivitiesResponse, zGetLoggedInAthleteClubsData, zGetLoggedInAthleteClubsResponse, zGetLoggedInAthleteData, zGetLoggedInAthleteResponse, zGetLoggedInAthleteStarredSegmentsData, zGetLoggedInAthleteStarredSegmentsResponse, zGetLoggedInAthleteZonesData, zGetLoggedInAthleteZonesResponse, zGetRouteAsGpxData, zGetRouteAsTcxData, zGetRouteByIdData, zGetRouteByIdResponse, zGetRoutesByAthleteIdData, zGetRoutesByAthleteIdResponse, zGetRouteStreamsData, zGetRouteStreamsResponse, zGetSegmentByIdData, zGetSegmentByIdResponse, zGetSegmentEffortByIdData, zGetSegmentEffortByIdResponse, zGetSegmentEffortStreamsData, zGetSegmentEffortStreamsResponse, zGetSegmentStreamsData, zGetSegmentStreamsResponse, zGetStatsData, zGetStatsResponse, zGetUploadByIdData, zGetUploadByIdResponse, zGetZonesByActivityIdData, zGetZonesByActivityIdResponse, zStarSegmentData, zStarSegmentResponse, zUpdateActivityByIdData, zUpdateActivityByIdResponse, zUpdateLoggedInAthleteData, zUpdateLoggedInAthleteResponse } from './zod.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = Options2<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * Get Athlete Stats
 *
 * Returns the activity stats of an athlete. Only includes data from activities set to Everyone visibilty.
 */
export const getStats = <ThrowOnError extends boolean = false>(options: Options<GetStatsData, ThrowOnError>) => {
    return (options.client ?? client).get<GetStatsResponses, GetStatsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetStatsData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetStatsResponse.parseAsync(data);
        },
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/athletes/{id}/stats',
        ...options
    });
};

/**
 * Get Authenticated Athlete
 *
 * Returns the currently authenticated athlete. Tokens with profile:read_all scope will receive a detailed athlete representation; all others will receive a summary representation.
 */
export const getLoggedInAthlete = <ThrowOnError extends boolean = false>(options?: Options<GetLoggedInAthleteData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLoggedInAthleteResponses, GetLoggedInAthleteErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetLoggedInAthleteData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetLoggedInAthleteResponse.parseAsync(data);
        },
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/athlete',
        ...options
    });
};

/**
 * Update Athlete
 *
 * Update the currently authenticated athlete. Requires profile:write scope.
 */
export const updateLoggedInAthlete = <ThrowOnError extends boolean = false>(options: Options<UpdateLoggedInAthleteData, ThrowOnError>) => {
    return (options.client ?? client).put<UpdateLoggedInAthleteResponses, UpdateLoggedInAthleteErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zUpdateLoggedInAthleteData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zUpdateLoggedInAthleteResponse.parseAsync(data);
        },
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/athlete',
        ...options
    });
};

/**
 * Get Zones
 *
 * Returns the the authenticated athlete's heart rate and power zones. Requires profile:read_all.
 */
export const getLoggedInAthleteZones = <ThrowOnError extends boolean = false>(options?: Options<GetLoggedInAthleteZonesData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLoggedInAthleteZonesResponses, GetLoggedInAthleteZonesErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetLoggedInAthleteZonesData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetLoggedInAthleteZonesResponse.parseAsync(data);
        },
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/athlete/zones',
        ...options
    });
};

/**
 * Get Segment
 *
 * Returns the specified segment. read_all scope required in order to retrieve athlete-specific segment information, or to retrieve private segments.
 */
export const getSegmentById = <ThrowOnError extends boolean = false>(options: Options<GetSegmentByIdData, ThrowOnError>) => {
    return (options.client ?? client).get<GetSegmentByIdResponses, GetSegmentByIdErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetSegmentByIdData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetSegmentByIdResponse.parseAsync(data);
        },
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/segments/{id}',
        ...options
    });
};

/**
 * List Starred Segments
 *
 * List of the authenticated athlete's starred segments. Private segments are filtered out unless requested by a token with read_all scope.
 */
export const getLoggedInAthleteStarredSegments = <ThrowOnError extends boolean = false>(options?: Options<GetLoggedInAthleteStarredSegmentsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLoggedInAthleteStarredSegmentsResponses, GetLoggedInAthleteStarredSegmentsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetLoggedInAthleteStarredSegmentsData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetLoggedInAthleteStarredSegmentsResponse.parseAsync(data);
        },
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/segments/starred',
        ...options
    });
};

/**
 * Star Segment
 *
 * Stars/Unstars the given segment for the authenticated athlete. Requires profile:write scope.
 */
export const starSegment = <ThrowOnError extends boolean = false>(options: Options<StarSegmentData, ThrowOnError>) => {
    return (options.client ?? client).put<StarSegmentResponses, StarSegmentErrors, ThrowOnError>({
        ...formDataBodySerializer,
        requestValidator: async (data) => {
            return await zStarSegmentData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zStarSegmentResponse.parseAsync(data);
        },
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/segments/{id}/starred',
        ...options,
        headers: {
            'Content-Type': null,
            ...options.headers
        }
    });
};

/**
 * List Segment Efforts
 *
 * Returns a set of the authenticated athlete's segment efforts for a given segment.  Requires subscription.
 */
export const getEffortsBySegmentId = <ThrowOnError extends boolean = false>(options: Options<GetEffortsBySegmentIdData, ThrowOnError>) => {
    return (options.client ?? client).get<GetEffortsBySegmentIdResponses, GetEffortsBySegmentIdErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetEffortsBySegmentIdData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetEffortsBySegmentIdResponse.parseAsync(data);
        },
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/segment_efforts',
        ...options
    });
};

/**
 * Explore segments
 *
 * Returns the top 10 segments matching a specified query.
 */
export const exploreSegments = <ThrowOnError extends boolean = false>(options: Options<ExploreSegmentsData, ThrowOnError>) => {
    return (options.client ?? client).get<ExploreSegmentsResponses, ExploreSegmentsErrors, ThrowOnError>({
        querySerializer: {
            array: {
                explode: false,
                style: 'form'
            }
        },
        requestValidator: async (data) => {
            return await zExploreSegmentsData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zExploreSegmentsResponse.parseAsync(data);
        },
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/segments/explore',
        ...options
    });
};

/**
 * Get Segment Effort
 *
 * Returns a segment effort from an activity that is owned by the authenticated athlete. Requires subscription.
 */
export const getSegmentEffortById = <ThrowOnError extends boolean = false>(options: Options<GetSegmentEffortByIdData, ThrowOnError>) => {
    return (options.client ?? client).get<GetSegmentEffortByIdResponses, GetSegmentEffortByIdErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetSegmentEffortByIdData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetSegmentEffortByIdResponse.parseAsync(data);
        },
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/segment_efforts/{id}',
        ...options
    });
};

/**
 * Create an Activity
 *
 * Creates a manual activity for an athlete, requires activity:write scope.
 */
export const createActivity = <ThrowOnError extends boolean = false>(options: Options<CreateActivityData, ThrowOnError>) => {
    return (options.client ?? client).post<CreateActivityResponses, CreateActivityErrors, ThrowOnError>({
        ...formDataBodySerializer,
        requestValidator: async (data) => {
            return await zCreateActivityData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zCreateActivityResponse.parseAsync(data);
        },
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/activities',
        ...options,
        headers: {
            'Content-Type': null,
            ...options.headers
        }
    });
};

/**
 * Get Activity
 *
 * Returns the given activity that is owned by the authenticated athlete. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
 */
export const getActivityById = <ThrowOnError extends boolean = false>(options: Options<GetActivityByIdData, ThrowOnError>) => {
    return (options.client ?? client).get<GetActivityByIdResponses, GetActivityByIdErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetActivityByIdData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetActivityByIdResponse.parseAsync(data);
        },
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/activities/{id}',
        ...options
    });
};

/**
 * Update Activity
 *
 * Updates the given activity that is owned by the authenticated athlete. Requires activity:write. Also requires activity:read_all in order to update Only Me activities
 */
export const updateActivityById = <ThrowOnError extends boolean = false>(options: Options<UpdateActivityByIdData, ThrowOnError>) => {
    return (options.client ?? client).put<UpdateActivityByIdResponses, UpdateActivityByIdErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zUpdateActivityByIdData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zUpdateActivityByIdResponse.parseAsync(data);
        },
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/activities/{id}',
        ...options,
        headers: {
            'Content-Type': '*/*',
            ...options.headers
        }
    });
};

/**
 * List Athlete Activities
 *
 * Returns the activities of an athlete for a specific identifier. Requires activity:read. Only Me activities will be filtered out unless requested by a token with activity:read_all.
 */
export const getLoggedInAthleteActivities = <ThrowOnError extends boolean = false>(options?: Options<GetLoggedInAthleteActivitiesData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLoggedInAthleteActivitiesResponses, GetLoggedInAthleteActivitiesErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetLoggedInAthleteActivitiesData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetLoggedInAthleteActivitiesResponse.parseAsync(data);
        },
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/athlete/activities',
        ...options
    });
};

/**
 * List Activity Laps
 *
 * Returns the laps of an activity identified by an identifier. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
 */
export const getLapsByActivityId = <ThrowOnError extends boolean = false>(options: Options<GetLapsByActivityIdData, ThrowOnError>) => {
    return (options.client ?? client).get<GetLapsByActivityIdResponses, GetLapsByActivityIdErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetLapsByActivityIdData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetLapsByActivityIdResponse.parseAsync(data);
        },
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/activities/{id}/laps',
        ...options
    });
};

/**
 * Get Activity Zones
 *
 * Summit Feature. Returns the zones of a given activity. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
 */
export const getZonesByActivityId = <ThrowOnError extends boolean = false>(options: Options<GetZonesByActivityIdData, ThrowOnError>) => {
    return (options.client ?? client).get<GetZonesByActivityIdResponses, GetZonesByActivityIdErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetZonesByActivityIdData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetZonesByActivityIdResponse.parseAsync(data);
        },
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/activities/{id}/zones',
        ...options
    });
};

/**
 * List Activity Comments
 *
 * Returns the comments on the given activity. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
 */
export const getCommentsByActivityId = <ThrowOnError extends boolean = false>(options: Options<GetCommentsByActivityIdData, ThrowOnError>) => {
    return (options.client ?? client).get<GetCommentsByActivityIdResponses, GetCommentsByActivityIdErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetCommentsByActivityIdData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetCommentsByActivityIdResponse.parseAsync(data);
        },
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/activities/{id}/comments',
        ...options
    });
};

/**
 * List Activity Kudoers
 *
 * Returns the athletes who kudoed an activity identified by an identifier. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
 */
export const getKudoersByActivityId = <ThrowOnError extends boolean = false>(options: Options<GetKudoersByActivityIdData, ThrowOnError>) => {
    return (options.client ?? client).get<GetKudoersByActivityIdResponses, GetKudoersByActivityIdErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetKudoersByActivityIdData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetKudoersByActivityIdResponse.parseAsync(data);
        },
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/activities/{id}/kudos',
        ...options
    });
};

/**
 * Get Club
 *
 * Returns a given a club using its identifier.
 */
export const getClubById = <ThrowOnError extends boolean = false>(options: Options<GetClubByIdData, ThrowOnError>) => {
    return (options.client ?? client).get<GetClubByIdResponses, GetClubByIdErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetClubByIdData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetClubByIdResponse.parseAsync(data);
        },
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/clubs/{id}',
        ...options
    });
};

/**
 * List Club Members
 *
 * Returns a list of the athletes who are members of a given club.
 */
export const getClubMembersById = <ThrowOnError extends boolean = false>(options: Options<GetClubMembersByIdData, ThrowOnError>) => {
    return (options.client ?? client).get<GetClubMembersByIdResponses, GetClubMembersByIdErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetClubMembersByIdData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetClubMembersByIdResponse.parseAsync(data);
        },
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/clubs/{id}/members',
        ...options
    });
};

/**
 * List Club Administrators
 *
 * Returns a list of the administrators of a given club.
 */
export const getClubAdminsById = <ThrowOnError extends boolean = false>(options: Options<GetClubAdminsByIdData, ThrowOnError>) => {
    return (options.client ?? client).get<GetClubAdminsByIdResponses, GetClubAdminsByIdErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetClubAdminsByIdData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetClubAdminsByIdResponse.parseAsync(data);
        },
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/clubs/{id}/admins',
        ...options
    });
};

/**
 * List Club Activities
 *
 * Retrieve recent activities from members of a specific club. The authenticated athlete must belong to the requested club in order to hit this endpoint. Pagination is supported. Athlete profile visibility is respected for all activities.
 */
export const getClubActivitiesById = <ThrowOnError extends boolean = false>(options: Options<GetClubActivitiesByIdData, ThrowOnError>) => {
    return (options.client ?? client).get<GetClubActivitiesByIdResponses, GetClubActivitiesByIdErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetClubActivitiesByIdData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetClubActivitiesByIdResponse.parseAsync(data);
        },
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/clubs/{id}/activities',
        ...options
    });
};

/**
 * List Athlete Clubs
 *
 * Returns a list of the clubs whose membership includes the authenticated athlete.
 */
export const getLoggedInAthleteClubs = <ThrowOnError extends boolean = false>(options?: Options<GetLoggedInAthleteClubsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLoggedInAthleteClubsResponses, GetLoggedInAthleteClubsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetLoggedInAthleteClubsData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetLoggedInAthleteClubsResponse.parseAsync(data);
        },
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/athlete/clubs',
        ...options
    });
};

/**
 * Get Equipment
 *
 * Returns an equipment using its identifier.
 */
export const getGearById = <ThrowOnError extends boolean = false>(options: Options<GetGearByIdData, ThrowOnError>) => {
    return (options.client ?? client).get<GetGearByIdResponses, GetGearByIdErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetGearByIdData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetGearByIdResponse.parseAsync(data);
        },
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/gear/{id}',
        ...options
    });
};

/**
 * Get Route
 *
 * Returns a route using its identifier. Requires read_all scope for private routes.
 */
export const getRouteById = <ThrowOnError extends boolean = false>(options: Options<GetRouteByIdData, ThrowOnError>) => {
    return (options.client ?? client).get<GetRouteByIdResponses, GetRouteByIdErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetRouteByIdData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetRouteByIdResponse.parseAsync(data);
        },
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/routes/{id}',
        ...options
    });
};

/**
 * List Athlete Routes
 *
 * Returns a list of the routes created by the authenticated athlete. Private routes are filtered out unless requested by a token with read_all scope.
 */
export const getRoutesByAthleteId = <ThrowOnError extends boolean = false>(options?: Options<GetRoutesByAthleteIdData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetRoutesByAthleteIdResponses, GetRoutesByAthleteIdErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetRoutesByAthleteIdData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetRoutesByAthleteIdResponse.parseAsync(data);
        },
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/athletes/{id}/routes',
        ...options
    });
};

/**
 * Export Route GPX
 *
 * Returns a GPX file of the route. Requires read_all scope for private routes.
 */
export const getRouteAsGpx = <ThrowOnError extends boolean = false>(options: Options<GetRouteAsGpxData, ThrowOnError>) => {
    return (options.client ?? client).get<GetRouteAsGpxResponses, GetRouteAsGpxErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetRouteAsGpxData.parseAsync(data);
        },
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/routes/{id}/export_gpx',
        ...options
    });
};

/**
 * Export Route TCX
 *
 * Returns a TCX file of the route. Requires read_all scope for private routes.
 */
export const getRouteAsTcx = <ThrowOnError extends boolean = false>(options: Options<GetRouteAsTcxData, ThrowOnError>) => {
    return (options.client ?? client).get<GetRouteAsTcxResponses, GetRouteAsTcxErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetRouteAsTcxData.parseAsync(data);
        },
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/routes/{id}/export_tcx',
        ...options
    });
};

/**
 * Upload Activity
 *
 * Uploads a new data file to create an activity from. Requires activity:write scope.
 */
export const createUpload = <ThrowOnError extends boolean = false>(options?: Options<CreateUploadData, ThrowOnError>) => {
    return (options?.client ?? client).post<CreateUploadResponses, CreateUploadErrors, ThrowOnError>({
        ...formDataBodySerializer,
        requestValidator: async (data) => {
            return await zCreateUploadData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zCreateUploadResponse.parseAsync(data);
        },
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/uploads',
        ...options,
        headers: {
            'Content-Type': null,
            ...options?.headers
        }
    });
};

/**
 * Get Upload
 *
 * Returns an upload for a given identifier. Requires activity:write scope.
 */
export const getUploadById = <ThrowOnError extends boolean = false>(options: Options<GetUploadByIdData, ThrowOnError>) => {
    return (options.client ?? client).get<GetUploadByIdResponses, GetUploadByIdErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetUploadByIdData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetUploadByIdResponse.parseAsync(data);
        },
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/uploads/{uploadId}',
        ...options
    });
};

/**
 * Get Activity Streams
 *
 * Returns the given activity's streams. Requires activity:read scope. Requires activity:read_all scope for Only Me activities.
 */
export const getActivityStreams = <ThrowOnError extends boolean = false>(options: Options<GetActivityStreamsData, ThrowOnError>) => {
    return (options.client ?? client).get<GetActivityStreamsResponses, GetActivityStreamsErrors, ThrowOnError>({
        querySerializer: {
            array: {
                explode: false,
                style: 'form'
            }
        },
        requestValidator: async (data) => {
            return await zGetActivityStreamsData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetActivityStreamsResponse.parseAsync(data);
        },
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/activities/{id}/streams',
        ...options
    });
};

/**
 * Get Segment Effort Streams
 *
 * Returns a set of streams for a segment effort completed by the authenticated athlete. Requires read_all scope.
 */
export const getSegmentEffortStreams = <ThrowOnError extends boolean = false>(options: Options<GetSegmentEffortStreamsData, ThrowOnError>) => {
    return (options.client ?? client).get<GetSegmentEffortStreamsResponses, GetSegmentEffortStreamsErrors, ThrowOnError>({
        querySerializer: {
            array: {
                explode: false,
                style: 'form'
            }
        },
        requestValidator: async (data) => {
            return await zGetSegmentEffortStreamsData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetSegmentEffortStreamsResponse.parseAsync(data);
        },
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/segment_efforts/{id}/streams',
        ...options
    });
};

/**
 * Get Segment Streams
 *
 * Returns the given segment's streams. Requires read_all scope for private segments.
 */
export const getSegmentStreams = <ThrowOnError extends boolean = false>(options: Options<GetSegmentStreamsData, ThrowOnError>) => {
    return (options.client ?? client).get<GetSegmentStreamsResponses, GetSegmentStreamsErrors, ThrowOnError>({
        querySerializer: {
            array: {
                explode: false,
                style: 'form'
            }
        },
        requestValidator: async (data) => {
            return await zGetSegmentStreamsData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetSegmentStreamsResponse.parseAsync(data);
        },
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/segments/{id}/streams',
        ...options
    });
};

/**
 * Get Route Streams
 *
 * Returns the given route's streams. Requires read_all scope for private routes.
 */
export const getRouteStreams = <ThrowOnError extends boolean = false>(options: Options<GetRouteStreamsData, ThrowOnError>) => {
    return (options.client ?? client).get<GetRouteStreamsResponses, GetRouteStreamsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetRouteStreamsData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetRouteStreamsResponse.parseAsync(data);
        },
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/routes/{id}/streams',
        ...options
    });
};
